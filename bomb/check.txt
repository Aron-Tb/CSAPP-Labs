Dump of assembler code for function phase_6:
   0x00000000004010f4 <+0>:	push   %r14
   0x00000000004010f6 <+2>:	push   %r13
   0x00000000004010f8 <+4>:	push   %r12
   0x00000000004010fa <+6>:	push   %rbp
   0x00000000004010fb <+7>:	push   %rbx
   0x00000000004010fc <+8>:	sub    $0x50,%rsp                      # rsp 向下 0x50
   0x0000000000401100 <+12>:	mov    %rsp,%r13                   # r13 = rsp
   0x0000000000401103 <+15>:	mov    %rsp,%rsi                   # rsi = rsp
   0x0000000000401106 <+18>:	call   0x40145c <read_six_numbers> # 读入6个数字: 读入位置在rsp处，依次存放6个数 
   0x000000000040110b <+23>:	mov    %rsp,%r14                   # r14 = rsp
   0x000000000040110e <+26>:	mov    $0x0,%r12d                  # r12d = 0
============================================== 循环1 =========================================================
   # r12d 循环前置为0
   0x0000000000401114 <+32>:	mov    %r13,%rbp                   # +32 : rbp = r13 (r13 是各个输入数字的地址）
   0x0000000000401117 <+35>:	mov    0x0(%r13),%eax              # 此处 eax 存放输入的各个数字
   0x000000000040111b <+39>:	sub    $0x1,%eax         # eax -= 1
   0x000000000040111e <+42>:	cmp    $0x5,%eax         # 输入的数字 - 1 后与5的大小关系
   0x0000000000401121 <+45>:	jbe    0x401128 <phase_6+52>  # 必须满足eax <= 5(即最大数字为6)， 跳转到+52
   0x0000000000401123 <+47>:	call   0x40143a <explode_bomb>      !!!!!!!
   # r12d++, 检查r12d != 6, 退出条件为r12d=6, 跳转+95
   0x0000000000401128 <+52>:	add    $0x1,%r12d        # +52: r12d + 1 : 循环开始前已置0 
   0x000000000040112c <+56>:	cmp    $0x6,%r12d        # r12d 存放某个变量，从1一直增加到6
   0x0000000000401130 <+60>:	je     0x401153 <phase_6+95>       # 循环退出条件：r12d=6,跳转 +95
   0x0000000000401132 <+62>:	mov    %r12d,%ebx        # r12d 不等于6, ebx = r12d, 所以ebx的值为1～5
===========================================循环 1.1 =========================================
   # ebx 初始值为 r12d (1~5)
   0x0000000000401135 <+65>:	movslq %ebx,%rax         # +65: rax = ebx (符号扩展）, rax的值为1～5
   0x0000000000401138 <+68>:	mov    (%rsp,%rax,4),%eax# eax 存放第2个到最后一个输入的数字
   0x000000000040113b <+71>:	cmp    %eax,0x0(%rbp)    # 比较eax 和 rbp 指向的数字是否相等(所有数字都不相同)  
   0x000000000040113e <+74>:	jne    0x401145 <phase_6+81>      # 必须满足：eax != rbp， 跳转到+81
   0x0000000000401140 <+76>:	call   0x40143a <explode_bomb>    
   # +81: 每轮循环后的操作：++ebx, 检查循环条件:ebx<6
   0x0000000000401145 <+81>:	add    $0x1,%ebx          
   0x0000000000401148 <+84>:	cmp    $0x5,%ebx          
   0x000000000040114b <+87>:	jle    0x401135 <phase_6+65>   
======================================== 退出条件1.1： ebx = 6 ==============================

   0x000000000040114d <+89>:	add    $0x4,%r13         # r13指向下一个数字     
   0x0000000000401151 <+93>:	jmp    0x401114 <phase_6+32> # 跳转到+32

===============================================退出条件1: r12d = 6 (+60)========================================

# 第一个循环检测 输入的6个数必须各不相同，而且最大为6

   0x0000000000401153 <+95>:	lea    0x18(%rsp),%rsi # rsi 指向6个输入数字后的位置(=0)
   0x0000000000401158 <+100>:	mov    %r14,%rax # r14=rsp, rax = rsp 
   0x000000000040115b <+103>:	mov    $0x7,%ecx # ecx=0x7

====================================== 循环2 ==============================
   # 每轮循环操作：对前5个数：(rax) = 7-(rax), rax +=4 ,  跳出循环条件: rax 指向6个数字后的位置 
   0x0000000000401160 <+108>:	mov    %ecx,%edx # edx = 0x7
   0x0000000000401162 <+110>:	sub    (%rax),%edx 
   0x0000000000401164 <+112>:	mov    %edx,(%rax) 
   0x0000000000401166 <+114>:	add    $0x4,%rax 
   0x000000000040116a <+118>:	cmp    %rsi,%rax
   0x000000000040116d <+121>:	jne    0x401160 <phase_6+108> 

====================================== 循环2退出 ===================

   0x000000000040116f <+123>:	mov    $0x0,%esi # esi = 0
   0x0000000000401174 <+128>:	jmp    0x401197 <phase_6+163> # -------> +163

====================================== + 130: 循环3 ==============================
   # 因为这里 ecx 肯定不等于1， 1的情况在 +143 后进行了处理
   # eax = 1, edx = 0x6032d0 , ecx存放输入的数
   0x0000000000401176 <+130>:	mov    0x8(%rdx),%rdx # 每次循环, rdx + 0x10 * (ecx-eax)
   0x000000000040117a <+134>:	add    $0x1,%eax # eax += 1
   # ecx != eax 时继续循环
   0x000000000040117d <+137>:	cmp    %ecx,%eax
   0x000000000040117f <+139>:	jne    0x401176 <phase_6+130> 
====================================== 退出条件3: ecx == eax  ==============================
   # edx 指向一个位置
   0x0000000000401181 <+141>:	jmp    0x401188 <phase_6+148>

====================================== + 143 ===============================================
   # rsi 表示数组中元素的偏移量
   0x0000000000401183 <+143>:	mov    $0x6032d0,%edx # edx = 0x6032d0 (存放:332)
   0x0000000000401188 <+148>:	mov    %rdx,0x20(%rsp,%rsi,2) # 从rsp+0x20处依次写入6个指针值(6个指针为 0x6032d0 + 0x10 *(ecx-1) ) 
   0x000000000040118d <+153>:	add    $0x4,%rsi # rsi += 4
   0x0000000000401191 <+157>:	cmp    $0x18,%rsi       # 比较 rsi : 0x18(24)
   0x0000000000401195 <+161>:	je     0x4011ab <phase_6+183>  # rsi == 0x18 jump  +183

====================================== + 163 ===============================================
   0x0000000000401197 <+163>:	mov    (%rsp,%rsi,1),%ecx # ecx存放被7 - 了的各个数 (rsi会在上面的指令中改变)
   0x000000000040119a <+166>:	cmp    $0x1,%ecx # 比较ecx: 1    # x <=6  7-x >= 1
   0x000000000040119d <+169>:	jle    0x401183 <phase_6+143> # ecx == 1, 原输入数为6  跳转+143
   # ecx > 1
   0x000000000040119f <+171>:	mov    $0x1,%eax # eax = 1
   0x00000000004011a4 <+176>:	mov    $0x6032d0,%edx #edx = 0x6032d0 # 同+143
   0x00000000004011a9 <+181>:	jmp    0x401176 <phase_6+130>
====================================== + 183 ===============================================
   0x00000000004011ab <+183>:	mov    0x20(%rsp),%rbx  # rbx = 第一个指针值
   0x00000000004011b0 <+188>:	lea    0x28(%rsp),%rax  # rax = 第二个指针值的地址
   0x00000000004011b5 <+193>:	lea    0x50(%rsp),%rsi  # rsi = 栈底的地址
   0x00000000004011ba <+198>:	mov    %rbx,%rcx  # rcx = 第一个指针值
===================================== + 201
   0x00000000004011bd <+201>:	mov    (%rax),%rdx # rdx = 第2、3..6个指针值 
   0x00000000004011c0 <+204>:	mov    %rdx,0x8(%rcx) # 将指针值 写入 上一个指针+8的地址
   # rax指向下一个指针值，当遍历完成后，跳出循环
   0x00000000004011c4 <+208>:	add    $0x8,%rax # rax += 8 (rax指向六个指针值中的一个，此处是后移指向下一个)
   0x00000000004011c8 <+212>:	cmp    %rsi,%rax      # 比较 rax 和 rsi
   0x00000000004011cb <+215>:	je     0x4011d2 <phase_6+222> # rax == rsi jump +222

   0x00000000004011cd <+217>:	mov    %rdx,%rcx # rcx = rdx
   0x00000000004011d0 <+220>:	jmp    0x4011bd <phase_6+201>

====================================== + 222 ===============================================
   0x00000000004011d2 <+222>:	movq   $0x0,0x8(%rdx) # 最后1个指针+8后的地址写入: 这里覆盖了返回地址！
   0x00000000004011da <+230>:	mov    $0x5,%ebp # ebp = 5 

============================================== 循环4 =============================================
   0x00000000004011df <+235>:	mov    0x8(%rbx),%rax # rbx是指针值, rax = 指针值+8 地址所存的数据:其实就是下一个指针
   0x00000000004011e3 <+239>:	mov    (%rax),%eax # eax = 下一个指针所存的数据
   0x00000000004011e5 <+241>:	cmp    %eax,(%rbx)     # 当前指针所存的数据一定要大于等于下一指针所存的数据(单调递减）
   0x00000000004011e7 <+243>:	jge    0x4011ee <phase_6+250>  # (rbx) >= eax jump +250 一定要跳转！

   0x00000000004011e9 <+245>:	call   0x40143a <explode_bomb> !!!!!!!!!!!
   0x00000000004011ee <+250>:	mov    0x8(%rbx),%rbx  # +250: rbx 变成了下一个指针值
   0x00000000004011f2 <+254>:	sub    $0x1,%ebp
   0x00000000004011f5 <+257>:	jne    0x4011df <phase_6+235> # ebp-1 后不为0 
============================================= 退出条件4: ebp == 0 ===================================

   0x00000000004011f7 <+259>:	add    $0x50,%rsp
   0x00000000004011fb <+263>:	pop    %rbx
   0x00000000004011fc <+264>:	pop    %rbp
   0x00000000004011fd <+265>:	pop    %r12
   0x00000000004011ff <+267>:	pop    %r13
   0x0000000000401201 <+269>:	pop    %r14
   0x0000000000401203 <+271>:	ret    
End of assembler dump.


(gdb) print *(int *) 0x6032d0
$1 = 332
(gdb) print *(int *) 0x6032e0
$2 = 168
(gdb) print *(int *) 0x6032f0
$3 = 924
(gdb) print *(int *) 0x603300
$4 = 691
(gdb) print *(int *) 0x603310
$5 = 477
(gdb) print *(int *) 0x603320
$6 = 443

